# File Handling in C Language 

## Introduction to File Handling

**File handling** enables C programs to store data permanently on secondary storage (hard disk) and retrieve it when needed.

**Why File Handling Matters:**
- **Data Persistence** - Information survives program termination
- **Large Data Management** - Handle datasets beyond memory capacity
- **Inter-Program Communication** - Share data between applications
- **Backup & Logging** - Maintain records and audit trails

## File Types in C

### Text Files
- Human-readable format
- Character-based storage
- ASCII encoding
- **Extensions:** `.txt`, `.csv`
- **Use Case:** Configuration files, logs, reports

### Binary Files
- Machine-readable format
- Faster processing speed
- Binary data storage
- **Extensions:** `.dat`, `.bin`
- **Use Case:** Databases, media files, serialized objects

## File Pointer Concept

A **file pointer** (`FILE *`) serves as an identifier and controller for file operations.

```c
FILE *fp;
```

The file pointer tracks the current position within the file and maintains the file's state.

## Opening and Closing Files

### Opening Files with fopen()

**Syntax:**
```c
fp = fopen("filename.txt", "mode");
```

### File Access Modes

| Mode | Operation | Behavior |
|------|-----------|----------|
| `r` | Read | Opens existing file; fails if file doesn't exist |
| `w` | Write | Creates new file or overwrites existing file |
| `a` | Append | Adds data to end; creates file if doesn't exist |
| `r+` | Read & Write | Opens existing file for both operations |
| `w+` | Read & Write | Creates new file; allows both operations |
| `a+` | Read & Append | Opens for reading and appending |
| `rb` | Read Binary | Opens binary file for reading |
| `wb` | Write Binary | Opens binary file for writing |

### Closing Files with fclose()

**Always close files** to prevent data loss and free system resources.

```c
fclose(fp);
```

## Writing Data to Files

### Character-Level Writing: fputc()

Writes a single character to the file.

```c
fputc('A', fp);
```

### String Writing: fputs()

Writes a string to the file (without newline).

```c
fputs("Hello File", fp);
```

### Formatted Writing: fprintf()

Writes formatted data similar to `printf()`.

```c
fprintf(fp, "Name: %s Age: %d", name, age);
```

## Reading Data from Files

### Character-Level Reading: fgetc()

Reads a single character from the file.

```c
char ch = fgetc(fp);
```

**Returns:** Character read, or `EOF` at end of file

### String Reading: fgets()

Reads a line of text (includes newline character).

```c
fgets(str, 50, fp);
```

**Parameters:** Buffer, maximum characters, file pointer

### Formatted Reading: fscanf()

Reads formatted data similar to `scanf()`.

```c
fscanf(fp, "%s %d", name, &age);
```

## Complete Text File Example

### Write and Read Operation

```c
#include <stdio.h>

int main() {
    FILE *fp;
    char name[20];
    
    // Writing to file
    fp = fopen("student.txt", "w");
    fprintf(fp, "Student Name: Rahul");
    fclose(fp);
    
    // Reading from file
    fp = fopen("student.txt", "r");
    fgets(name, 20, fp);
    printf("%s", name);
    fclose(fp);
    
    return 0;
}
```

**Output:** `Student Name: Rahul`

## Binary File Operations

### Writing Structures to Binary Files

Binary files efficiently store complex data structures.

```c
#include <stdio.h>

struct student {
    int id;
    char name[20];
};

int main() {
    FILE *fp;
    struct student s = {1, "Amit"};
    
    fp = fopen("stud.dat", "wb");
    fwrite(&s, sizeof(s), 1, fp);
    fclose(fp);
    
    return 0;
}
```

**fwrite() Parameters:**
- Address of data
- Size of each element
- Number of elements
- File pointer

### Reading Structures from Binary Files

```c
struct student s;
FILE *fp;

fp = fopen("stud.dat", "rb");
fread(&s, sizeof(s), 1, fp);
fclose(fp);

printf("ID: %d, Name: %s", s.id, s.name);
```

**fread() Parameters:** Same as `fwrite()`

## File Positioning Functions

### ftell() - Get Current Position

Returns the current byte position of the file pointer.

```c
long position = ftell(fp);
```

### fseek() - Move File Pointer

Moves the file pointer to a specific location.

```c
fseek(fp, offset, origin);
```

**Origin Values:**
- `SEEK_SET` - Beginning of file
- `SEEK_CUR` - Current position
- `SEEK_END` - End of file

**Example:**
```c
fseek(fp, 0, SEEK_END);  // Move to end
long size = ftell(fp);    // Get file size
```

### rewind() - Reset to Beginning

Moves the file pointer to the start of the file.

```c
rewind(fp);
```

Equivalent to: `fseek(fp, 0, SEEK_SET)`

## Error Handling

### Checking File Opening Success

**Always verify** that files opened successfully.

```c
FILE *fp = fopen("data.txt", "r");

if(fp == NULL) {
    printf("Error: File not found or cannot be opened\n");
    return 1;
}
```

### Additional Error Checks

```c
// Check for end of file
if(feof(fp)) {
    printf("End of file reached\n");
}

// Check for file errors
if(ferror(fp)) {
    printf("Error occurred during file operation\n");
}
```

## Real-World Applications

**Student Record Systems** - Store and retrieve student information

**Banking Systems** - Transaction logs, account data persistence

**Logging Systems** - Application logs, error tracking, audit trails

**Payroll Management** - Employee records, salary information

**Embedded Systems** - Configuration data, sensor readings storage

**Database Management** - Index files, data storage backends

## Mini Project: Student Record Management System

### Project Features

- Add new student records
- Display all students
- Search for specific students
- Store records permanently in binary file

### Implementation Approach

**Step 1:** Define student structure
```c
struct student {
    int rollNo;
    char name[50];
    float marks;
};
```

**Step 2:** Add student function
```c
void addStudent() {
    FILE *fp = fopen("students.dat", "ab");
    struct student s;
    
    printf("Enter Roll No: ");
    scanf("%d", &s.rollNo);
    printf("Enter Name: ");
    scanf("%s", s.name);
    printf("Enter Marks: ");
    scanf("%f", &s.marks);
    
    fwrite(&s, sizeof(s), 1, fp);
    fclose(fp);
}
```

**Step 3:** Display all records
```c
void displayStudents() {
    FILE *fp = fopen("students.dat", "rb");
    struct student s;
    
    while(fread(&s, sizeof(s), 1, fp)) {
        printf("Roll: %d, Name: %s, Marks: %.2f\n", 
               s.rollNo, s.name, s.marks);
    }
    
    fclose(fp);
}
```

### Program Flow

1. Display menu (Add/Display/Search/Exit)
2. Take user choice
3. Execute corresponding operation
4. Repeat until exit

## Step-by-Step: Binary File Writing

**Step 1:** Define the data structure
```c
struct student {
    int id;
    char name[20];
};
```

**Step 2:** Create and initialize data
```c
struct student s = {101, "John"};
```

**Step 3:** Open file in binary write mode
```c
FILE *fp = fopen("student.dat", "wb");
```

**Step 4:** Write data using fwrite()
```c
fwrite(&s, sizeof(s), 1, fp);
```

**Step 5:** Close the file
```c
fclose(fp);
```

## Exam Preparation

### Quick Recall Questions

**Q: What is a file?**
A collection of related data stored permanently on secondary storage.

**Q: Difference between text and binary files?**
Text files are human-readable and store ASCII characters; binary files store data in binary format, are faster to process, but not human-readable.

**Q: What is a FILE pointer?**
A special pointer type that references file stream objects and controls file operations.

**Q: Why use binary files over text files?**
Binary files are more efficient for storing structured data, consume less space, and offer faster read/write operations.

**Q: What happens if you forget to close a file?**
Data may not be written completely (buffering issues), memory leaks may occur, and file locks may prevent other programs from accessing the file.

### Detailed Explanation Questions

**Explain file modes in C:**
File modes determine how a file is accessed. Read mode (`r`) opens existing files for reading only. Write mode (`w`) creates new files or overwrites existing ones. Append mode (`a`) adds data to the end of files. Combined modes like `r+`, `w+`, and `a+` allow simultaneous reading and writing with different behaviors. Binary modes (`rb`, `wb`) handle non-text data.

**Describe the purpose of file positioning functions:**
`ftell()` returns the current byte position in a file. `fseek()` allows random access by moving the file pointer to any location. `rewind()` resets the pointer to the beginning. These functions enable efficient navigation through large files without reading sequentially.

### Practical Viva Questions

**Write syntax of fopen():**
```c
FILE *fp = fopen("filename", "mode");
```

**Store a structure in a binary file:**
```c
struct student s = {1, "Alice"};
FILE *fp = fopen("data.dat", "wb");
fwrite(&s, sizeof(s), 1, fp);
fclose(fp);
```

**Explain fseek() with example:**
```c
fseek(fp, 0, SEEK_END);  // Move to end
long size = ftell(fp);    // Get file size
fseek(fp, 0, SEEK_SET);  // Move to beginning
```

## Common Pitfalls to Avoid

**Forgetting to close files** - Always use `fclose()` to flush buffers and free resources

**Using incorrect file modes** - Verify mode matches your operation (read/write/append)

**Not checking NULL pointer** - Always validate `fopen()` return value

**Buffer overflow in fgets()** - Ensure buffer size matches the second parameter

**Mixing text and binary modes** - Don't use text functions on binary files and vice versa

**Ignoring return values** - Check return values of `fread()`, `fwrite()`, `fscanf()`

## Best Practices

- ✓ Always check if file opened successfully
- ✓ Close files immediately after use
- ✓ Use appropriate file modes for your operation
- ✓ Prefer binary files for structured data
- ✓ Use text files for human-readable data
- ✓ Implement proper error handling
- ✓ Clear buffers when switching between read/write
- ✓ Use `sizeof()` for structure operations

## Summary

File handling is a **fundamental system-level concept** in C programming, essential for building robust applications. It's extensively used in databases, operating systems, embedded systems, and virtually all real-world software that requires data persistence.

**Key Takeaways:**
- Files provide permanent storage beyond program execution
- Text files for readability, binary files for efficiency
- Proper error handling prevents data loss
- File positioning enables random access
- Structures with binary files create simple database systems

---