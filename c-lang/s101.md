## ‚ö°Preprocessor Directives, Macros & Header Files in C

---

## 1. üß± What are Preprocessor Directives?

üëâ Preprocessor Directives are special instructions given to the **C Preprocessor** before the actual compilation of code begins.

- They start with `#` (hash symbol).
- They tell the compiler to perform specific actions like including files, defining constants, or setting conditional compilation.

### Common Preprocessor Directives:
```c
#include <stdio.h>      // Include standard header files
#define PI 3.14        // Define a macro constant
```


## 2. üéØ What are Macros?
- üëâ A Macro is a piece of code defined by #define that gets replaced by its value wherever it appears in the code.
- Example of a Macro:
```c
#define PI 3.14

int main() {
    float area = PI * 5 * 5;
    printf("Area of circle: %.2f\n", area);
    return 0;
}
```
- Here, PI is replaced by 3.14 during preprocessing.
- No memory is allocated for PI; it's a simple text replacement.

## 3. üìö What are Header Files?
- üëâ A Header File is a file containing function declarations, macros, constants, and type definitions that can be included in a C program using #include.
- Example Header File: stdio.h
- Contains functions like printf(), scanf()

**Why use Header Files?**
- Reusability of code
- Organize functions & definitions
- Easy management of large programs

**üîß Real-Time Example of Preprocessor Directives & Macros**
```c
#include <stdio.h>    // Header file inclusion

#define GREETING "Welcome to C Programming!"   // Macro Definition

int main() {
    printf("%s\n", GREETING);
    return 0;
}
```
- üëâ During preprocessing, GREETING will be replaced by "Welcome to C Programming!".

## 4. üìã List of Common Header Files & Their Functions
| Header File | Common Functions Provided                          |
| ----------- | -------------------------------------------------- |
| `stdio.h`   | `printf()`, `scanf()`, `fgets()`, `fputs()`        |
| `stdlib.h`  | `malloc()`, `free()`, `exit()`, `atoi()`           |
| `string.h`  | `strcpy()`, `strlen()`, `strcmp()`, `strcat()`     |
| `math.h`    | `sqrt()`, `pow()`, `sin()`, `cos()`, `log()`       |
| `ctype.h`   | `isdigit()`, `isalpha()`, `toupper()`, `tolower()` |
| `time.h`    | `time()`, `clock()`, `difftime()`, `localtime()`   |
| `limits.h`  | Defines limits of integer types (e.g., `INT_MAX`)  |
| `conio.h`\* | `getch()`, `clrscr()` (\*mostly used in Turbo C)   |


**‚ö° Pro Tip**
- üëâ Use #define for constant values instead of hard-coding numbers.
- üëâ Always include necessary header files to avoid compilation errors.

## üéØ Summary
- Preprocessor Directives help customize the code before compilation.
- Macros are simple text replacements that make the code more readable and easier to maintain.
- Header Files provide standard functions and constants that speed up development.
- Knowing important header files helps you write efficient and organized code.

---

##  Input and Output Functions

### üñ•Ô∏è 1Ô∏è‚É£ Output Function: `printf()`
`printf()` is used to display output (text, variables, numbers) to the console (screen).

*Syntax*:
```c
printf("format string", variables...);
```

*Example*
```c
#include <stdio.h>

int main() {
    int age = 25;
    char grade = 'A';
    float price = 99.99;

    printf("Age: %d\n", age);
    printf("Grade: %c\n", grade);
    printf("Price: %.2f\n", price);

    return 0;
}
```

**Notes on printf()**
- Format specifiers (like %d, %c, %f) define how the variables are displayed.
- \n moves the cursor to the next line.
- Supports formatting options (e.g., decimal precision, field width).

### ‚å®Ô∏è 2Ô∏è‚É£ Input Function: scanf()
- scanf() is used to read input from the user via keyboard.

*Syntax:*
```c
scanf("format string", &variable);
```
- The & symbol (address-of operator) tells the compiler where to store the input.

*Example*
```c
#include <stdio.h>

int main() {
    int age;
    char grade;
    float price;

    printf("Enter your age: ");
    scanf("%d", &age);

    printf("Enter your grade (A-F): ");
    scanf(" %c", &grade);  // Notice the space before %c to consume any leftover newline

    printf("Enter product price: ");
    scanf("%f", &price);

    printf("\nYour age: %d\n", age);
    printf("Your grade: %c\n", grade);
    printf("Product price: %.2f\n", price);

    return 0;
}
```

**Important Tips üìù**
- üß± Always use & with variables in scanf() to pass the memory address.
- üìö For reading strings, use %s and pass the array name without &.
```c
char name[50];
scanf("%s", name);
```
- ‚ö†Ô∏è Beware of buffer overflow when reading strings ‚Äì use width specifiers or fgets() for safer input.

## ‚úÖ Input & Output Functions in C


| **Function** | **Purpose**                                      | **Syntax Example**                               | **Usage Example**                                         | **Notes** |
|-------------|--------------------------------------------------|--------------------------------------------------|------------------------------------------------------------|-----------|
| `printf()`  | Print formatted output to console               | `printf("Age: %d\n", age);`                    | ```int age = 25;printf("Age: %d\n", age);``` | Most flexible, used for all types of output |
| `puts()`    | Print a string followed by a newline           | `puts("Hello, World!");`                       | ```puts("Welcome!");```                         | Simple, no format specifiers |
| `putchar()` | Print a single character                       | `putchar('A');`                                  | ```char ch = 'B';putchar(ch);```            | Good for character-level output |
| `scanf()`   | Read formatted input from user                 | `scanf("%d", &age);`                             | ```int age;scanf("%d", &age);```            | Use `&` for variables |
| `gets()`    | Read a string from input *(unsafe, deprecated)* | `gets(str);`                                    | ```char str[50];gets(str);```               | Avoid in modern programs (buffer overflow risk) |
| `fgets()`   | Safely read string input with size limit       | `fgets(str, sizeof(str), stdin);`               | ```char name[50];fgets(name, sizeof(name), stdin);``` | Recommended for reading strings safely |
| `getchar()` | Read a single character from input             | `ch = getchar();`                                | ```char ch;ch = getchar();```               | Simple, useful for char input |
| `putchar()` | Print a single character                       | `putchar(ch);`                                    | ```char ch = 'A';putchar(ch);```            | Easy for character output |

---
---

### ‚úÖ Example Usage Comparison

### Example 1 ‚Äì Using `printf()`:
```c
int age = 30;
printf("Your age is %d\n", age);
```
#### Example 2 ‚Äì Using puts():
```c
puts("Welcome to C programming!");
```

#### Example 3 ‚Äì Using putchar():
```c
char ch = 'C';
putchar(ch);
```

#### Example 4 ‚Äì Using scanf():
```c
int num;
scanf("%d", &num);
```

#### Example 5 ‚Äì Using fgets():
```c
char name[50];
fgets(name, sizeof(name), stdin);
```
#### Example 6 ‚Äì Using getchar():
```c
char ch;
ch = getchar();
putchar(ch);
```

---
#  üß± Variables

üëâ A **Variable** is a named storage in memory used to store data that may change during program execution.

- **Declaration Syntax**:
```c
data_type variable_name;
```
- **Initialization Example:**
```c
int age = 25;
float price = 99.99;
char grade = 'A';
```

**Types of Variables:**
| Type                  | Scope & Lifetime                                                   |
| --------------------- | ------------------------------------------------------------------ |
| **Local Variable**    | Declared inside a function, exists only during function execution. |
| **Global Variable**   | Declared outside all functions, accessible throughout the program. |
| **Static Variable**   | Retains its value between function calls.                          |
| **Constant Variable** | Cannot be changed after initialization (`const`).                  |


**Real-Time Example:**
```c
#include <stdio.h>

int globalVar = 100;  // Global Variable

void showCounter() {
    static int counter = 0;  // Static Variable
    counter++;
    printf("Counter: %d\n", counter);
}

int main() {
    int localVar = 10;        // Local Variable
    const float PI = 3.1416; // Constant Variable

    printf("Global: %d\n", globalVar);
    printf("Local: %d\n", localVar);
    printf("Constant PI: %.4f\n", PI);

    showCounter();
    showCounter();
    showCounter();

    return 0;
}
```

### üìù Variable Naming Rules & Best Practices
*‚úÖ Rules for Naming Variables:*
- Must start with a letter (a‚Äìz, A‚ÄìZ) or underscore (_).
- Subsequent characters can be letters, digits (0‚Äì9), or underscores.
- Cannot use C keywords as variable names (e.g., int, for, return).
- Case-sensitive: age and Age are different variables.

*Good Variable Naming Practices:*
1. Be descriptive:
    - ‚ùå Bad: int a;
    - ‚úÖ Good: int studentAge;

2. Use camelCase or snake_case:
    - camelCase: studentAge
    - snake_case: student_age

3. Avoid single letters except for simple loops:
```c
for (int i = 0; i < 10; i++) { ... }  // OK
```

**Example:**
```c
int employeeCount = 50;
float accountBalance = 1024.75;
char gradeLetter = 'A';
```

----
## üß± Memory Model in C (Detailed)
- üëâ Memory divided into several segments:

| Segment             | Purpose                                                                       |
| ------------------- | ----------------------------------------------------------------------------- |
| üìö **Code Segment** | Contains executable instructions (machine code).                              |
| üß± **Data Segment** | Stores global and static variables initialized by the programmer.             |
| üî¢ **BSS Segment**  | Stores uninitialized global and static variables (initialized to zero).       |
| üåê **Heap**         | Dynamic memory allocation (`malloc`, `free`). Programmer manages memory.      |
| üìã **Stack**        | Local variables, function call parameters, return addresses (LIFO structure). |


![](https://d8it4huxumps7.cloudfront.net/uploads/images/6851382354377_memory_layout_in_c_inside.jpg?d=2000x2000)

**Example**

![](https://miro.medium.com/1*tPX9wx16aObaHQZAiEsM5w.png)

---
## ‚úÖ Format Specifiers
- üëâ **Format Specifiers** are special placeholders used in functions like `printf()` and `scanf()` to specify the type of data to be printed or read.

- They tell the compiler how to interpret the data, ensuring correct input/output formatting.


**Common Format Specifiers**

| Specifier | Data Type      | Example |
|-----------|--------------|---------|
| `%d`      | `int` (decimal integer) | `int age = 25; printf("%d", age);` |
| `%c`      | `char` (single character) | `char letter = 'A'; printf("%c", letter);` |
| `%f`      | `float` (floating-point number) | `float price = 99.99; printf("%f", price);` |
| `%lf`     | `double` (double precision float) | `double pi = 3.14159; printf("%lf", pi);` |
| `%s`      | `string` (character array) | `char name[] = "Alice"; printf("%s", name);` |
| `%u`      | `unsigned int` (positive integer) | `unsigned int count = 100; printf("%u", count);` |
| `%x`      | Integer in hexadecimal | `int num = 255; printf("%x", num);` |
| `%o`      | Integer in octal | `int num = 8; printf("%o", num);` |
| `%%`      | Prints a percent sign | `printf("%%");` ‚Üí prints `%` |


**Example ‚Äì Using Format Specifiers**

```c
#include <stdio.h>

int main() {
    int age = 30;
    char grade = 'A';
    float price = 99.99;
    double pi = 3.14159265;
    char name[] = "Bob";

    printf("Age: %d\n", age);
    printf("Grade: %c\n", grade);
    printf("Price: %.2f\n", price);   // Display 2 decimal places
    printf("Pi: %.4lf\n", pi);        // Display 4 decimal places
    printf("Name: %s\n", name);

    return 0;
}
```

**Notes & Tips**
- üéØ Always match the format specifier to the correct data type to avoid undefined behavior.
- üõ†Ô∏è For precise floating-point display, use precision specifiers:
```c
printf("%.3f", price);  // Displays 3 decimal places
```
- üö® Mismatch Example (Avoid This!):
```c
printf("%d", 99.99);  // Incorrect: leads to garbage or error
```

---
## ‚ö° Keywords in C
- üëâ 32 Reserved Keywords. Example categories:

| Category         | Example Keywords                               |
| ---------------- | ---------------------------------------------- |
| Data Types       | `int`, `float`, `char`, `double`, `void`       |
| Control Flow     | `if`, `else`, `switch`, `case`, `default`      |
| Loop Control     | `for`, `while`, `do`, `break`, `continue`      |
| Storage Class    | `auto`, `register`, `static`, `extern`         |
| Function Control | `return`                                       |
| Qualifiers       | `const`, `volatile`                            |
| Others           | `sizeof`, `typedef`, `enum`, `struct`, `union` |


**üëâ Example:**
```c
#include <stdio.h>

typedef struct {
    int id;
    char name[50];
} Employee;

int main() {
    Employee emp = {1, "Alice"};
    printf("ID: %d, Name: %s\n", emp.id, emp.name);
    return 0;
}
```

---
## üß± Data Types in C 
- Every data type in C has a fixed size, which determines the range of values it can hold

**‚ñ∂Ô∏è Primary Data Types:**
| Data Type | Size (Typical) | Example                |
| --------- | -------------- | ---------------------- |
| `int`     | 4 bytes        | `int age = 30;`        |
| `char`    | 1 byte         | `char letter = 'A';`   |
| `float`   | 4 bytes        | `float price = 99.99;` |
| `double`  | 8 bytes        | `double pi = 3.14159;` |





**‚ñ∂Ô∏è Derived Data Types:**
| Data Type | Description                                            |
| --------- | ------------------------------------------------------ |
| Array     | Collection of elements of same type. `int numbers[5];` |
| Pointer   | Stores memory address. `int *ptr;`                     |
| Function  | Block of reusable code. `int add(int, int);`           |

**‚ñ∂Ô∏è User-Defined Data Types:**
| Data Type | Description                         |
| --------- | ----------------------------------- |
| `struct`  | Multiple data items under one name. |
| `union`   | Shares memory among members.        |
| `enum`    | Named integer constants.            |


**üí° Additional Tips**
- ‚úÖ Use sizeof() to check size of any data type:
```c
printf("Size of int: %lu bytes\n", sizeof(int));
```

- ‚úÖ Prefer const for constants:
```c
const int DAYS_IN_WEEK = 7;
```
- ‚úÖ Always use meaningful variable names.
- ‚úÖ Avoid dangling pointers and memory leaks with dynamic allocation.

### Datatype Overflow
- In C programming, overflow occurs when a variable tries to store a value that exceeds the range allowed by its data type. 
- Essentially, the value is ‚Äútoo big‚Äù (or sometimes ‚Äútoo small‚Äù) for the memory allocated to that type.

| Data Type   | Size (bits) | Range (signed)                                          | Range (unsigned)                |
| ----------- | ----------- | ------------------------------------------------------- | ------------------------------- |
| `char`      | 8           | -128 to 127                                             | 0 to 255                        |
| `short`     | 16          | -32,768 to 32,767                                       | 0 to 65,535                     |
| `int`       | 32          | -2,147,483,648 to 2,147,483,647                         | 0 to 4,294,967,295              |
| `long long` | 64          | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 | 0 to 18,446,744,073,709,551,615 |

**What Happens in Overflow**
1. Signed integers: Overflow leads to undefined behavior in C. This means the program might wrap around, crash, or behave unpredictably.
2. Unsigned integers: Overflow wraps around modulo the maximum value + 1.

```c
#include <stdio.h>
int main() {
    unsigned char x = 255;
    x = x + 1;  // overflow
    printf("%u\n", x); // Output: 0
    return 0;
}
```
- unsigned char can only hold 0‚Äì255. Adding 1 wraps it around to 0.

```c
#include <stdio.h>
int main() {
    int x = 2147483647; // max int
    x = x + 1;          // overflow
    printf("%d\n", x);  // Result is undefined
    return 0;
}
```
- adding 1 exceeds the max value for int. In practice, it might wrap to -2147483648 on many systems, but officially it‚Äôs undefined behavior.

**Why Overflow Matters**
- Can cause bugs that are hard to detect.
- Can be exploited in security attacks (buffer overflow, integer overflow vulnerabilities).
- Important to check limits when performing arithmetic, especially in embedded systems or financial calculations.
