# âš™ï¸ Functions in C

## ğŸ”¹ What is a Function?

A function is a block of code that performs a specific task and can be called multiple times in a program.

**Analogy:** Think of a function like a machine in a workshop â€” you give it raw materials (inputs), it processes them, and gives back a finished product (output).

### ğŸ§© Example
```c
#include <stdio.h>

void greet() {
    printf("Hello, C Programmer!\n");
}

int main() {
    greet();  // calling the function
    return 0;
}
```

**Output:**
```
Hello, C Programmer!
```

## ğŸ”¹ Why Use Functions?

âœ… Avoid code repetition  
âœ… Improve readability & structure  
âœ… Easier debugging and testing  
âœ… Divide big problems into smaller tasks  
âœ… Enable code reusability

**Analogy:** Imagine writing an ATM program â€” instead of writing the "check balance" logic everywhere, create a `checkBalance()` function and reuse it.

## ğŸ”¹ Types of Functions in C

| Type | Description | Example |
|------|-------------|---------|
| Library Functions | Built-in functions provided by C | `printf()`, `scanf()`, `strlen()`, `sqrt()` |
| User-defined Functions | Created by the programmer | `add()`, `calculateArea()` |

---

## ğŸ§© 1ï¸âƒ£ Syntax of a Function

```c
return_type function_name(parameter_list) {
    // body
    return value; // optional
}
```

**Example:**
```c
int add(int a, int b) {
    return a + b;
}
```

---

## ğŸ§© 2ï¸âƒ£ Function Declaration, Definition & Call

| Step | Purpose | Example |
|------|---------|---------|
| Declaration | Tells compiler the function exists | `int add(int, int);` |
| Definition | Contains actual body | `int add(int a, int b) { return a + b; }` |
| Call | Executes the function | `add(5, 10);` |

### ğŸ’¡ Example
```c
#include <stdio.h>

int add(int, int);   // declaration

int main() {
    int result = add(5, 10);  // function call
    printf("Sum = %d\n", result);
    return 0;
}

int add(int x, int y) {       // definition
    return x + y;
}
```

**Output:**
```
Sum = 15
```

---

## ğŸ§© 3ï¸âƒ£ Function Categories (Based on Arguments & Return Type)

| Case | Arguments | Return Value | Example |
|------|-----------|--------------|---------|
| 1 | âŒ No | âŒ No | `void greet()` |
| 2 | âœ… Yes | âŒ No | `void printSum(int a, int b)` |
| 3 | âŒ No | âœ… Yes | `int getNumber()` |
| 4 | âœ… Yes | âœ… Yes | `int add(int a, int b)` |

### Example 1 â€” No arguments, no return
```c
void greet() {
    printf("Good Morning!\n");
}

int main() {
    greet();
    return 0;
}
```

### Example 2 â€” With arguments, no return
```c
void printSum(int a, int b) {
    printf("Sum = %d\n", a + b);
}

int main() {
    printSum(3, 7);
    return 0;
}
```

### Example 3 â€” No arguments, with return
```c
int getInput() {
    int num;
    printf("Enter a number: ");
    scanf("%d", &num);
    return num;
}

int main() {
    int x = getInput();
    printf("You entered %d\n", x);
    return 0;
}
```

### Example 4 â€” With arguments, with return
```c
int multiply(int a, int b) {
    return a * b;
}

int main() {
    int result = multiply(4, 5);
    printf("Product = %d\n", result);
    return 0;
}
```

---

## ğŸ§© 4ï¸âƒ£ Function Call Stack & Execution Flow

When a function is called:

1. Control transfers from `main()` to the function.
2. Local variables and parameters are created in stack memory.
3. After execution, control returns to the calling point.

**Analogy:** Like calling a friend for help â€” you pause your task, let them finish their job, then resume where you left off.

---

## ğŸ§© 5ï¸âƒ£ Call by Value vs Call by Reference

### ğŸ”¸ Call by Value

A copy of the variable is passed â†’ Original remains unchanged.

```c
void update(int x) {
    x = x + 10;
}

int main() {
    int a = 5;
    update(a);
    printf("%d", a);  // still 5
    return 0;
}
```

### ğŸ”¸ Call by Reference

Memory address is passed â†’ Original variable changes.

```c
void update(int *x) {
    *x = *x + 10;
}

int main() {
    int a = 5;
    update(&a);
    printf("%d", a);  // becomes 15
    return 0;
}
```

**Analogy:**  
Passing by value is like sending a photocopy,  
Passing by reference is like giving your original document.

---

## ğŸ§© 6ï¸âƒ£ Recursion (Function Calling Itself)

A recursive function is one that calls itself until a base condition is met.

### Example â€” Factorial
```c
#include <stdio.h>

int fact(int n) {
    if (n == 0)
        return 1;
    else
        return n * fact(n - 1);
}

int main() {
    printf("Factorial = %d", fact(5));
    return 0;
}
```

**Output:**
```
Factorial = 120
```

**Analogy:** Like mirrors facing each other â€” each reflection calls the next until it ends.

---

## ğŸ§© 7ï¸âƒ£ Nested Functions (Conceptual)

C doesn't support functions inside functions directly, but you can call one function from another.

```c
void displayMessage() {
    printf("Welcome!\n");
}

void greet() {
    displayMessage();
    printf("Hope you're doing well!\n");
}

int main() {
    greet();
    return 0;
}
```

---

## ğŸ§© 8ï¸âƒ£ Scope and Lifetime of Variables

| Type | Where declared | Lifetime | Example |
|------|----------------|----------|---------|
| Local | Inside a function | Until function ends | `int x = 10;` |
| Global | Outside all functions | Until program ends | `int count;` |
| Static | Inside a function (retains value between calls) | Until program ends | `static int c = 0;` |

### Example â€” Static Variable
```c
void counter() {
    static int count = 0;
    count++;
    printf("Called %d times\n", count);
}

int main() {
    counter();
    counter();
    counter();
    return 0;
}
```

**Output:**
```
Called 1 times
Called 2 times
Called 3 times
```

---

## ğŸ§© 9ï¸âƒ£ Real-World Examples

### Example 1 â€” Bank Account Functions
```c
float deposit(float balance, float amount) {
    return balance + amount;
}

float withdraw(float balance, float amount) {
    if (amount > balance)
        printf("Insufficient funds!\n");
    else
        balance -= amount;
    return balance;
}
```

### Example 2 â€” Temperature Conversion
```c
float toCelsius(float f) {
    return (f - 32) * 5 / 9;
}

float toFahrenheit(float c) {
    return (c * 9 / 5) + 32;
}
```

### Example 3 â€” Calculator Using Functions
```c
int add(int a, int b) { return a + b; }
int sub(int a, int b) { return a - b; }
int mul(int a, int b) { return a * b; }
float divi(int a, int b) { return (float)a / b; }

int main() {
    int x = 10, y = 5;
    printf("Sum = %d\n", add(x, y));
    printf("Diff = %d\n", sub(x, y));
    printf("Prod = %d\n", mul(x, y));
    printf("Div = %.2f\n", divi(x, y));
}
```

---

## âš™ï¸ ğŸ”Ÿ Edge Cases & Pitfalls

| âŒ Pitfall | ğŸ§  Explanation |
|-----------|----------------|
| Missing return statement | Undefined result for non-void function |
| Forgetting declaration before main | Compiler error in C89 standard |
| Infinite recursion | Stack overflow |
| Type mismatch in parameters | Unexpected output |
| Using global vars inside function | Can cause unwanted side effects |
| Forgetting `&` when passing by reference | Value won't actually change |

---

## ğŸ§© 1ï¸âƒ£1ï¸âƒ£ Summary Table

| Concept | Description | Example |
|---------|-------------|---------|
| Function Declaration | Prototype before main | `int add(int, int);` |
| Function Definition | Code body | `int add(int a, int b){...}` |
| Function Call | Executes function | `add(2,3);` |
| Call by Value | Copy passed | `f(a)` |
| Call by Reference | Address passed | `f(&a)` |
| Recursive Function | Calls itself | `fact(n-1)` |
| Static Variable | Retains value | `static int x` |

---

## ğŸš€ Real-Life Analogies

| Real-World Scenario | C Concept |
|---------------------|-----------|
| Vending machine (input â†’ process â†’ output) | Function |
| Chef following a recipe repeatedly | Function reuse |
| Calculator performing add/sub | Library functions |
| Calling a helper to do a task | Function call |
| Infinite mirror reflections | Recursion |