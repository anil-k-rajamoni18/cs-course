# ⚙️ Functions in C

## 🔹 What is a Function?

A function is a block of code that performs a specific task and can be called multiple times in a program.

**Analogy:** Think of a function like a machine in a workshop — you give it raw materials (inputs), it processes them, and gives back a finished product (output).

### 🧩 Example
```c
#include <stdio.h>

void greet() {
    printf("Hello, C Programmer!\n");
}

int main() {
    greet();  // calling the function
    return 0;
}
```

**Output:**
```
Hello, C Programmer!
```

## 🔹 Why Use Functions?

✅ Avoid code repetition  
✅ Improve readability & structure  
✅ Easier debugging and testing  
✅ Divide big problems into smaller tasks  
✅ Enable code reusability

**Analogy:** Imagine writing an ATM program — instead of writing the "check balance" logic everywhere, create a `checkBalance()` function and reuse it.

## 🔹 Types of Functions in C

| Type | Description | Example |
|------|-------------|---------|
| Library Functions | Built-in functions provided by C | `printf()`, `scanf()`, `strlen()`, `sqrt()` |
| User-defined Functions | Created by the programmer | `add()`, `calculateArea()` |

---

## 🧩 1️⃣ Syntax of a Function

```c
return_type function_name(parameter_list) {
    // body
    return value; // optional
}
```

**Example:**
```c
int add(int a, int b) {
    return a + b;
}
```

---

## 🧩 2️⃣ Function Declaration, Definition & Call

| Step | Purpose | Example |
|------|---------|---------|
| Declaration | Tells compiler the function exists | `int add(int, int);` |
| Definition | Contains actual body | `int add(int a, int b) { return a + b; }` |
| Call | Executes the function | `add(5, 10);` |

### 💡 Example
```c
#include <stdio.h>

int add(int, int);   // declaration

int main() {
    int result = add(5, 10);  // function call
    printf("Sum = %d\n", result);
    return 0;
}

int add(int x, int y) {       // definition
    return x + y;
}
```

**Output:**
```
Sum = 15
```

---

## 🧩 3️⃣ Function Categories (Based on Arguments & Return Type)

| Case | Arguments | Return Value | Example |
|------|-----------|--------------|---------|
| 1 | ❌ No | ❌ No | `void greet()` |
| 2 | ✅ Yes | ❌ No | `void printSum(int a, int b)` |
| 3 | ❌ No | ✅ Yes | `int getNumber()` |
| 4 | ✅ Yes | ✅ Yes | `int add(int a, int b)` |

### Example 1 — No arguments, no return
```c
void greet() {
    printf("Good Morning!\n");
}

int main() {
    greet();
    return 0;
}
```

### Example 2 — With arguments, no return
```c
void printSum(int a, int b) {
    printf("Sum = %d\n", a + b);
}

int main() {
    printSum(3, 7);
    return 0;
}
```

### Example 3 — No arguments, with return
```c
int getInput() {
    int num;
    printf("Enter a number: ");
    scanf("%d", &num);
    return num;
}

int main() {
    int x = getInput();
    printf("You entered %d\n", x);
    return 0;
}
```

### Example 4 — With arguments, with return
```c
int multiply(int a, int b) {
    return a * b;
}

int main() {
    int result = multiply(4, 5);
    printf("Product = %d\n", result);
    return 0;
}
```

---

## 🧩 4️⃣ Function Call Stack & Execution Flow

When a function is called:

1. Control transfers from `main()` to the function.
2. Local variables and parameters are created in stack memory.
3. After execution, control returns to the calling point.

**Analogy:** Like calling a friend for help — you pause your task, let them finish their job, then resume where you left off.

---

## 🧩 5️⃣ Call by Value vs Call by Reference

### 🔸 Call by Value

A copy of the variable is passed → Original remains unchanged.

```c
void update(int x) {
    x = x + 10;
}

int main() {
    int a = 5;
    update(a);
    printf("%d", a);  // still 5
    return 0;
}
```

### 🔸 Call by Reference

Memory address is passed → Original variable changes.

```c
void update(int *x) {
    *x = *x + 10;
}

int main() {
    int a = 5;
    update(&a);
    printf("%d", a);  // becomes 15
    return 0;
}
```

**Analogy:**  
Passing by value is like sending a photocopy,  
Passing by reference is like giving your original document.

---

## 🧩 6️⃣ Recursion (Function Calling Itself)

A recursive function is one that calls itself until a base condition is met.

### Example — Factorial
```c
#include <stdio.h>

int fact(int n) {
    if (n == 0)
        return 1;
    else
        return n * fact(n - 1);
}

int main() {
    printf("Factorial = %d", fact(5));
    return 0;
}
```

**Output:**
```
Factorial = 120
```

**Analogy:** Like mirrors facing each other — each reflection calls the next until it ends.

---

## 🧩 7️⃣ Nested Functions (Conceptual)

C doesn't support functions inside functions directly, but you can call one function from another.

```c
void displayMessage() {
    printf("Welcome!\n");
}

void greet() {
    displayMessage();
    printf("Hope you're doing well!\n");
}

int main() {
    greet();
    return 0;
}
```

---

## 🧩 8️⃣ Scope and Lifetime of Variables

| Type | Where declared | Lifetime | Example |
|------|----------------|----------|---------|
| Local | Inside a function | Until function ends | `int x = 10;` |
| Global | Outside all functions | Until program ends | `int count;` |
| Static | Inside a function (retains value between calls) | Until program ends | `static int c = 0;` |

### Example — Static Variable
```c
void counter() {
    static int count = 0;
    count++;
    printf("Called %d times\n", count);
}

int main() {
    counter();
    counter();
    counter();
    return 0;
}
```

**Output:**
```
Called 1 times
Called 2 times
Called 3 times
```

---

## 🧩 9️⃣ Real-World Examples

### Example 1 — Bank Account Functions
```c
float deposit(float balance, float amount) {
    return balance + amount;
}

float withdraw(float balance, float amount) {
    if (amount > balance)
        printf("Insufficient funds!\n");
    else
        balance -= amount;
    return balance;
}
```

### Example 2 — Temperature Conversion
```c
float toCelsius(float f) {
    return (f - 32) * 5 / 9;
}

float toFahrenheit(float c) {
    return (c * 9 / 5) + 32;
}
```

### Example 3 — Calculator Using Functions
```c
int add(int a, int b) { return a + b; }
int sub(int a, int b) { return a - b; }
int mul(int a, int b) { return a * b; }
float divi(int a, int b) { return (float)a / b; }

int main() {
    int x = 10, y = 5;
    printf("Sum = %d\n", add(x, y));
    printf("Diff = %d\n", sub(x, y));
    printf("Prod = %d\n", mul(x, y));
    printf("Div = %.2f\n", divi(x, y));
}
```

---

## ⚙️ 🔟 Edge Cases & Pitfalls

| ❌ Pitfall | 🧠 Explanation |
|-----------|----------------|
| Missing return statement | Undefined result for non-void function |
| Forgetting declaration before main | Compiler error in C89 standard |
| Infinite recursion | Stack overflow |
| Type mismatch in parameters | Unexpected output |
| Using global vars inside function | Can cause unwanted side effects |
| Forgetting `&` when passing by reference | Value won't actually change |

---

## 🧩 1️⃣1️⃣ Summary Table

| Concept | Description | Example |
|---------|-------------|---------|
| Function Declaration | Prototype before main | `int add(int, int);` |
| Function Definition | Code body | `int add(int a, int b){...}` |
| Function Call | Executes function | `add(2,3);` |
| Call by Value | Copy passed | `f(a)` |
| Call by Reference | Address passed | `f(&a)` |
| Recursive Function | Calls itself | `fact(n-1)` |
| Static Variable | Retains value | `static int x` |

---

## 🚀 Real-Life Analogies

| Real-World Scenario | C Concept |
|---------------------|-----------|
| Vending machine (input → process → output) | Function |
| Chef following a recipe repeatedly | Function reuse |
| Calculator performing add/sub | Library functions |
| Calling a helper to do a task | Function call |
| Infinite mirror reflections | Recursion |