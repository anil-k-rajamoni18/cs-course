# üß† High-Level Strategy (Before the Plan)

## Key Principles

- Focus on patterns, not random problems
- Prioritize Medium problems (FAANG mostly asks these)
- Practice explaining while coding
- Use one language only for speed & muscle memory

## Daily Time Split (3 hours)

- ‚è±Ô∏è **30 min** ‚Üí Concept + pattern understanding
- ‚úçÔ∏è **2 hrs** ‚Üí Solve 4‚Äì6 problems
- üé§ **30 min** ‚Üí Revise + explain out loud

---

# üóìÔ∏è 30-Day Structured DSA Plan

## üîπ WEEK 1 ‚Äì Foundations & Linear Data Structures

**Goal:** Absolute confidence with arrays, strings, hashing

### Day 1 ‚Äì Time & Space Complexity

**Concepts:**
- Big-O, Big-Œ©, Big-Œò
- Amortized analysis
- Arrays vs LinkedList tradeoffs

**Problems (4):**
- LC 217 ‚Äì Contains Duplicate
- LC 1929 ‚Äì Concatenation of Array
- LC 1480 ‚Äì Running Sum
- LC 242 ‚Äì Valid Anagram

### Day 2 ‚Äì Arrays (Basics ‚Üí Medium)

**Patterns:** Prefix sum, frequency array

**Problems (5):**
- LC 53 ‚Äì Maximum Subarray
- LC 121 ‚Äì Best Time to Buy & Sell Stock
- LC 238 ‚Äì Product of Array Except Self
- LC 560 ‚Äì Subarray Sum Equals K
- LC 1 ‚Äì Two Sum

### Day 3 ‚Äì Strings

**Patterns:** Frequency map, two pointers

**Problems (5):**
- LC 125 ‚Äì Valid Palindrome
- LC 424 ‚Äì Longest Repeating Character Replacement
- LC 49 ‚Äì Group Anagrams
- LC 3 ‚Äì Longest Substring Without Repeating Characters
- LC 5 ‚Äì Longest Palindromic Substring

### Day 4 ‚Äì Hash Tables

**Patterns:** Count, index mapping

**Problems (4):**
- LC 347 ‚Äì Top K Frequent Elements
- LC 36 ‚Äì Valid Sudoku
- LC 128 ‚Äì Longest Consecutive Sequence
- LC 454 ‚Äì 4Sum II

### Day 5 ‚Äì Linked Lists

**Patterns:** Slow/Fast pointers, dummy node

**Problems (5):**
- LC 206 ‚Äì Reverse Linked List
- LC 21 ‚Äì Merge Two Sorted Lists
- LC 141 ‚Äì Linked List Cycle
- LC 19 ‚Äì Remove Nth Node From End
- LC 138 ‚Äì Copy List with Random Pointer

### Day 6 ‚Äì Stack & Queue

**Patterns:** Monotonic stack

**Problems (5):**
- LC 20 ‚Äì Valid Parentheses
- LC 155 ‚Äì Min Stack
- LC 739 ‚Äì Daily Temperatures
- LC 84 ‚Äì Largest Rectangle in Histogram
- LC 232 ‚Äì Implement Queue using Stacks

### Day 7 ‚Äì Weekly Review + Mock

- Re-solve 2 previously failed problems
- Do 1 mock interview (Pramp / self-record)
- Revise patterns learned

---

## üîπ WEEK 2 ‚Äì Trees & Recursion

**Goal:** Master DFS/BFS & recursion thinking

### Day 8 ‚Äì Tree Basics

**Problems (4):**
- LC 144 ‚Äì Preorder Traversal
- LC 94 ‚Äì Inorder Traversal
- LC 145 ‚Äì Postorder Traversal
- LC 104 ‚Äì Max Depth of Binary Tree

### Day 9 ‚Äì Binary Trees (DFS)

**Patterns:** Bottom-up recursion

**Problems (5):**
- LC 110 ‚Äì Balanced Binary Tree
- LC 543 ‚Äì Diameter of Binary Tree
- LC 124 ‚Äì Binary Tree Maximum Path Sum
- LC 236 ‚Äì LCA
- LC 101 ‚Äì Symmetric Tree

### Day 10 ‚Äì BFS / Level Order

**Problems (4):**
- LC 102 ‚Äì Level Order Traversal
- LC 199 ‚Äì Right Side View
- LC 637 ‚Äì Average of Levels
- LC 111 ‚Äì Min Depth

### Day 11 ‚Äì Binary Search Trees

**Problems (4):**
- LC 98 ‚Äì Validate BST
- LC 230 ‚Äì Kth Smallest in BST
- LC 700 ‚Äì Search in BST
- LC 450 ‚Äì Delete Node in BST

### Day 12 ‚Äì Recursion & Backtracking

**Problems (4):**
- LC 78 ‚Äì Subsets
- LC 46 ‚Äì Permutations
- LC 39 ‚Äì Combination Sum
- LC 79 ‚Äì Word Search

### Day 13 ‚Äì Review + Mock

- Revisit hard tree problems
- Practice explaining recursion
- One timed mock (45 mins)

---

## üîπ WEEK 3 ‚Äì Graphs, Heaps & Binary Search

**Goal:** Handle non-linear problems confidently

### Day 14 ‚Äì Binary Search Patterns

**Problems (5):**
- LC 704 ‚Äì Binary Search
- LC 33 ‚Äì Search in Rotated Sorted Array
- LC 153 ‚Äì Find Min in Rotated Array
- LC 875 ‚Äì Koko Eating Bananas
- LC 1011 ‚Äì Capacity To Ship Packages

### Day 15 ‚Äì Heaps / Priority Queue

**Problems (4):**
- LC 215 ‚Äì Kth Largest Element
- LC 295 ‚Äì Find Median from Data Stream
- LC 973 ‚Äì K Closest Points
- LC 621 ‚Äì Task Scheduler

### Day 16 ‚Äì Graph Basics (BFS/DFS)

**Problems (4):**
- LC 200 ‚Äì Number of Islands
- LC 133 ‚Äì Clone Graph
- LC 695 ‚Äì Max Area of Island
- LC 417 ‚Äì Pacific Atlantic Water Flow

### Day 17 ‚Äì Advanced Graphs

**Problems (3):**
- LC 207 ‚Äì Course Schedule
- LC 210 ‚Äì Course Schedule II
- LC 743 ‚Äì Network Delay Time

### Day 18 ‚Äì Review + Mock

- One FAANG-level mock
- Focus on graph explanation clarity

---

## üîπ WEEK 4 ‚Äì Dynamic Programming + Interview Readiness

**Goal:** DP confidence + interview polish

### Day 19 ‚Äì DP Basics

**Problems (4):**
- LC 70 ‚Äì Climbing Stairs
- LC 198 ‚Äì House Robber
- LC 746 ‚Äì Min Cost Climbing Stairs
- LC 509 ‚Äì Fibonacci

### Day 20 ‚Äì 2D DP

**Problems (4):**
- LC 62 ‚Äì Unique Paths
- LC 1143 ‚Äì Longest Common Subsequence
- LC 72 ‚Äì Edit Distance
- LC 64 ‚Äì Minimum Path Sum

### Day 21 ‚Äì Advanced DP

**Problems (3):**
- LC 300 ‚Äì Longest Increasing Subsequence
- LC 322 ‚Äì Coin Change
- LC 416 ‚Äì Partition Equal Subset Sum

### Day 22 ‚Äì Greedy

**Problems (4):**
- LC 55 ‚Äì Jump Game
- LC 45 ‚Äì Jump Game II
- LC 435 ‚Äì Non-overlapping Intervals
- LC 134 ‚Äì Gas Station

### Day 23 ‚Äì Mixed Hard Problems

**Problems (3):**
- LC 76 ‚Äì Minimum Window Substring
- LC 84 ‚Äì Histogram (redo)
- LC 124 ‚Äì Tree Max Path (redo)

### Day 24‚Äì26 ‚Äì Full Mock Interview Mode

**Daily 2 mocks**

**Platforms:**
- Pramp
- Interviewing.io
- LeetCode Interview Simulator

### Day 27‚Äì29 ‚Äì Weak Area Fix

- Reattempt failed problems
- Revise patterns cheatsheet
- Dry-run explanations

### Day 30 ‚Äì Final Readiness

**2 random Medium problems**

**Review:**
- Common patterns
- Time/space tradeoffs
- Edge cases

---

# üß™ Practice Strategy Summary

| Level | Count / Day |
|-------|-------------|
| Easy | 1 |
| Medium | 3‚Äì4 |
| Hard | 0‚Äì1 |

**Focus:** Medium problems with pattern recognition

---

# üíª Java vs Python (Important)

## ‚úÖ Recommendation: Java

**Why?**
- You already use it professionally
- Better control over memory
- Preferred in FAANG backend interviews

### Must-Know Java Tools
- HashMap, HashSet
- ArrayDeque (use instead of Stack)
- PriorityQueue
- Collections.sort
- Custom comparator (VERY IMPORTANT)

### Python (If You Choose It)
- collections.Counter
- defaultdict
- heapq
- Slicing & list comprehensions

üëâ **Pick ONE and stick to it**

---

# üé§ Mock Interview & Communication Tips

## How to Explain

1. Restate problem
2. Clarify constraints
3. Naive approach
4. Optimized approach
5. Time & space complexity
6. Code

## Common Mistakes (Experienced Devs Make)

‚ùå Over-engineering  
‚ùå Skipping edge cases  
‚ùå Not thinking aloud  
‚ùå Jumping to DP too fast

---

# üìå Final Advice

- **Consistency > Volume**
- **Patterns > Problem count**
- **Explanation > Perfect code**


---
# üß† DSA PATTERN-WISE CHEATSHEET (INTERVIEW FOCUSED)

## 1Ô∏è‚É£ Two Pointers

### When to use
- Sorted array / string
- Pairs, triplets, palindromes
- Reduce O(n¬≤) ‚Üí O(n)

### Template
```java
int l = 0, r = n - 1;
while (l < r) {
    if (condition) l++;
    else r--;
}
```

### Key Problems
- Two Sum II
- Valid Palindrome
- Container With Most Water
- 3Sum

### Common Traps
‚ùå Forget sorted requirement  
‚ùå Missing duplicate skipping

---

## 2Ô∏è‚É£ Sliding Window

### When
- Subarrays / substrings
- "Longest / shortest / count"
- Continuous range

### Template
```java
int left = 0;
for (int right = 0; right < n; right++) {
    // expand
    while (invalid) {
        // shrink
        left++;
    }
}
```

### Problems
- Longest Substring Without Repeating
- Minimum Window Substring
- Max Sum Subarray of Size K
- Longest Repeating Character Replacement

### Trick
üëâ Fixed window vs Variable window

---

## 3Ô∏è‚É£ Hashing / Frequency Map

### When
- Counting
- Lookup in O(1)
- Index mapping

### Java Tools
```java
Map<Character, Integer> map = new HashMap<>();
map.getOrDefault(key, 0);
```

### Problems
- Two Sum
- Group Anagrams
- Subarray Sum Equals K
- Top K Frequent Elements

### Trap
‚ùå Forgetting negative numbers (prefix sum)

---

## 4Ô∏è‚É£ Prefix Sum

### When
- Range sum queries
- Subarray problems

### Formula
```java
prefix[i] = prefix[i-1] + nums[i];
sum(l,r) = prefix[r] - prefix[l-1];
```

### Problems
- Subarray Sum Equals K
- Range Sum Query
- Product Except Self

---

## 5Ô∏è‚É£ Stack (Monotonic Stack)

### When
- Next Greater / Smaller
- Histogram / span problems

### Template
```java
Deque<Integer> stack = new ArrayDeque<>();
while (!stack.isEmpty() && nums[stack.peek()] < curr) {
    stack.pop();
}
```

### Problems
- Daily Temperatures
- Largest Rectangle in Histogram
- Valid Parentheses
- Min Stack

### Rule
- Increasing stack ‚Üí next smaller
- Decreasing stack ‚Üí next greater

---

## 6Ô∏è‚É£ Linked List

### Patterns
- Dummy node
- Slow & fast pointer
- Reverse list

### Template (Reverse)
```java
ListNode prev = null, curr = head;
while (curr != null) {
    ListNode next = curr.next;
    curr.next = prev;
    prev = curr;
    curr = next;
}
```

### Problems
- Reverse Linked List
- Cycle Detection
- Merge Two Sorted Lists
- Copy Random List

---

## 7Ô∏è‚É£ Binary Search (Beyond Arrays)

### When
- Sorted space
- Answer range
- Min / max feasible value

### Template
```java
while (l <= r) {
    int mid = l + (r - l) / 2;
    if (check(mid)) r = mid - 1;
    else l = mid + 1;
}
```

### Problems
- Koko Eating Bananas
- Search Rotated Array
- Capacity to Ship Packages

### Mindset
üëâ Binary search on answer, not array

---

## 8Ô∏è‚É£ Tree DFS (Recursion)

### When
- Tree traversal
- Height / depth / path problems

### Template
```java
int dfs(TreeNode root) {
    if (root == null) return 0;
    int left = dfs(root.left);
    int right = dfs(root.right);
    return Math.max(left, right) + 1;
}
```

### Problems
- Max Depth
- Diameter
- Max Path Sum
- Balanced Tree

### Tip
üëâ Bottom-up recursion

---

## 9Ô∏è‚É£ Tree BFS (Level Order)

### When
- Level based logic
- Nearest node

### Template
```java
Queue<TreeNode> q = new LinkedList<>();
q.offer(root);
while (!q.isEmpty()) {
    int size = q.size();
    for (int i = 0; i < size; i++) {
        TreeNode node = q.poll();
    }
}
```

### Problems
- Level Order
- Right Side View
- Min Depth

---

## üîü Graph DFS / BFS

### When
- Grid problems
- Connected components
- Cycle detection

### Template (DFS)
```java
void dfs(int r, int c) {
    if (out || visited) return;
    visited[r][c] = true;
    dfs(r+1,c); dfs(r-1,c);
}
```

### Problems
- Number of Islands
- Clone Graph
- Course Schedule
- Pacific Atlantic

### Graph Types
- Directed / Undirected
- Weighted / Unweighted

---

## 1Ô∏è‚É£1Ô∏è‚É£ Heap / Priority Queue

### When
- Top K
- Min / max tracking

### Java
```java
PriorityQueue<Integer> pq = new PriorityQueue<>();
```

### Problems
- Kth Largest Element
- Median from Data Stream
- Task Scheduler

### Trick
- Min-heap by default
- Max-heap ‚Üí custom comparator

---

## 1Ô∏è‚É£2Ô∏è‚É£ Dynamic Programming (DP)

### Step Process
1. Define state
2. Recurrence
3. Base case
4. Optimize space

### 1D DP
```java
dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);
```

**Problems:**
- House Robber
- Climbing Stairs

### 2D DP
```java
dp[i][j] = dp[i-1][j] + dp[i][j-1];
```

**Problems:**
- LCS
- Edit Distance
- Unique Paths

---

## 1Ô∏è‚É£3Ô∏è‚É£ Greedy

### When
- Local optimal ‚Üí global optimal

### Problems
- Jump Game
- Gas Station
- Interval Scheduling

### Test
üëâ Sort first, then decide

---

## 1Ô∏è‚É£4Ô∏è‚É£ Backtracking

### When
- All combinations / permutations

### Template
```java
void backtrack(List<Integer> path) {
    if (condition) return;
    for (...) {
        path.add(x);
        backtrack(path);
        path.remove(path.size()-1);
    }
}
```

### Problems
- Subsets
- Permutations
- Combination Sum

---

## üéØ INTERVIEW GOLDEN RULES

‚úÖ Always mention time & space  
‚úÖ Clarify constraints  
‚úÖ Talk while coding  
‚ùå Don't jump to DP immediately  
‚ùå Don't over-optimize early

---
# üéØ FAANG-ONLY DSA PROBLEM LIST (PATTERN-WISE)

**Target:** Medium-heavy dominance (this clears 80‚Äì90% of FAANG rounds)

---

## 1Ô∏è‚É£ Two Pointers

| Problem | Why FAANG loves it |
|---------|-------------------|
| Container With Most Water | Optimal pointer movement |
| 3Sum | Duplicate handling |
| Valid Palindrome II | Edge cases |
| Trapping Rain Water | Two-pointer optimization |
| Sort Colors | In-place logic |

üëâ **Master concept:** Pointer movement logic explanation

---

## 2Ô∏è‚É£ Sliding Window

| Problem | Key Pattern |
|---------|------------|
| Longest Substring Without Repeating | Variable window |
| Minimum Window Substring | Hard FAANG classic |
| Longest Repeating Character Replacement | Frequency control |
| Permutation in String | Fixed window |
| Max Consecutive Ones III | Shrink logic |

üî• **Redo Minimum Window Substring twice**

---

## 3Ô∏è‚É£ Hashing / Prefix Sum

| Problem | Why |
|---------|-----|
| Two Sum | Baseline |
| Subarray Sum Equals K | Negative numbers |
| Longest Consecutive Sequence | O(n) trick |
| Group Anagrams | Key encoding |
| Top K Frequent Elements | Heap + map |

---

## 4Ô∏è‚É£ Stack (Monotonic)

| Problem | Interview Signal |
|---------|-----------------|
| Daily Temperatures | Classic monotonic |
| Largest Rectangle in Histogram | Hard but common |
| Trapping Rain Water | Stack variant |
| Next Greater Element II | Circular array |
| Valid Parentheses | Stack basics |

---

## 5Ô∏è‚É£ Linked List

| Problem | Pattern |
|---------|---------|
| Reverse Linked List | Pointer mastery |
| Linked List Cycle | Fast/slow |
| Merge Two Sorted Lists | Dummy node |
| Remove Nth Node From End | One pass |
| Copy List with Random Pointer | Map + pointers |

---

## 6Ô∏è‚É£ Binary Search (Advanced)

| Problem | Concept |
|---------|---------|
| Search in Rotated Sorted Array | Pivot logic |
| Find Minimum in Rotated Array | Boundary handling |
| Koko Eating Bananas | Binary on answer |
| Capacity To Ship Packages | Feasibility check |
| Median of Two Sorted Arrays | FAANG hard |

‚ö†Ô∏è **Even partial logic explanation scores points**

---

## 7Ô∏è‚É£ Trees ‚Äì DFS

| Problem | Core Skill |
|---------|-----------|
| Max Depth of Binary Tree | Base DFS |
| Diameter of Binary Tree | Global variable |
| Binary Tree Maximum Path Sum | Post-order |
| Lowest Common Ancestor | Recursive logic |
| Path Sum III | Prefix sum + DFS |

---

## 8Ô∏è‚É£ Trees ‚Äì BFS

| Problem | Use Case |
|---------|----------|
| Binary Tree Level Order | Queue |
| Right Side View | Level thinking |
| Min Depth | Early exit |
| Zigzag Level Order | Toggle logic |

---

## 9Ô∏è‚É£ Graphs

| Problem | FAANG Signal |
|---------|-------------|
| Number of Islands | Grid DFS |
| Clone Graph | Graph traversal |
| Course Schedule | Topological sort |
| Pacific Atlantic Water Flow | Multi-source BFS |
| Network Delay Time | Dijkstra |

üî• **Course Schedule is MUST-MASTER**

---

## üîü Heap / Priority Queue

| Problem | Pattern |
|---------|---------|
| Kth Largest Element | Heap size control |
| Top K Frequent Elements | Bucket / heap |
| Find Median from Data Stream | Two heaps |
| Task Scheduler | Greedy + heap |
| K Closest Points | Distance logic |

---

## 1Ô∏è‚É£1Ô∏è‚É£ Dynamic Programming (FAANG Core)

| Problem | Level |
|---------|-------|
| Climbing Stairs | Entry |
| House Robber | Core |
| Coin Change | Medium |
| Longest Increasing Subsequence | Optimization |
| Edit Distance | DP classic |
| Longest Common Subsequence | 2D DP |

‚ö†Ô∏è **You should explain DP state clearly, code can be iterative or recursive**

---

## 1Ô∏è‚É£2Ô∏è‚É£ Greedy

| Problem | Reason |
|---------|--------|
| Jump Game | Reachability |
| Jump Game II | Min steps |
| Gas Station | Circular logic |
| Merge Intervals | Sorting |
| Non-overlapping Intervals | Interval greedy |

---

## 1Ô∏è‚É£3Ô∏è‚É£ Backtracking

| Problem | Pattern |
|---------|---------|
| Subsets | Power set |
| Permutations | Swap / visited |
| Combination Sum | Reuse logic |
| Word Search | Grid backtracking |

---

## üß™ HOW TO USE THIS LIST (VERY IMPORTANT)

### First Pass (20 days)
- Solve all Medium
- Skip hard if stuck >40 min
- Write clean code

### Second Pass (Last 10 days)
- Re-solve without looking
- Explain aloud
- Optimize space/time

---

## üé§ FAANG INTERVIEW EXPECTATION

| Skill | Weight |
|-------|--------|
| Pattern recognition | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| Communication | ‚≠ê‚≠ê‚≠ê‚≠ê |
| Perfect code | ‚≠ê‚≠ê‚≠ê |
| Edge cases | ‚≠ê‚≠ê‚≠ê‚≠ê |
